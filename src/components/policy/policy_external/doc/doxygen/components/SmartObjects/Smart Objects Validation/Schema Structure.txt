/*! \page components_smartobjects_validation_items Schema structure: Schema Items

In order to create new Schema (new object of class NsSmartDeviceLink::NsSmartObjects::CSmartSchema) client first must define all required Schema Items. Actually every Schema is a tree of respective Schema Items. Each node and leaf of that tree defines structural rules for some Smart Object data structure.

Schema Items are represented as class hierarchy. The base class for all schema items is a NsSmartDeviceLink::NsSmartObjects::ISchemaItem class. This base class defines generic validation interface for Schema Items.

To define special elements with always successful or always failing validation there are two special Schema Items: NsSmartDeviceLink::NsSmartObjects::CAlwaysTrueSchemaItem and NsSmartDeviceLink::NsSmartObjects::CAlwaysFalseSchemaItem.

NsSmartDeviceLink::NsSmartObjects::CBoolSchemaItem is used for boolean values and has no parameters (only verifies that respective Smart Object is really has boolean value).

NsSmartDeviceLink::NsSmartObjects::TNumberSchemaItem is template Schema Item that can be used for both integer and floating point values. In addition to the regular type verification it is possible to set min and max value range (these values are optional).

NsSmartDeviceLink::NsSmartObjects::TEnumSchemaItem is used to verify any custom client-defined enum.

NsSmartDeviceLink::NsSmartObjects::CStringSchemaItem is used to verify a string values. As optional parameter max length of the string could be set.

NsSmartDeviceLink::NsSmartObjects::CArraySchemaItem provides validation for array. Can be used to verify special type and array size.

NsSmartDeviceLink::NsSmartObjects::CObjectSchemaItem used in case when Schema Item includes another Schema Item. Actually this is only way to create tree node of new Schema. All other Schema Items will be used only to become leafs of validation tree.

After creation of all required Schema Items (which is actually bind in the tree) it is possible to create Schema.
Schema can be initialized not only by raw root Schema Item, but also by special abstraction called Member (defined by NsSmartDeviceLink::NsSmartObjects::CObjectSchemaItem::SMember class). So every root item (NsSmartDeviceLink::NsSmartObjects::CObjectSchemaItem) firstly should be wrapped as Member. This wrapping process also allows to set "is mandatory" status for every Member.

 and pass root Schema Item as initial parameter to the new Schema.

Currently Schemas are generated by the InterfaceGenerator. For supported ALRPC.v1/.v2 Schema has following structure:

<pre>

ROOT
 |
 -- PARAMS
 |       |
 |       -- FUNCTION_ID
 |       |
 |       -- MESSAGE_TYPE
 |       |
 |       -- CORRELATION_ID
 |       |
 |       -- PROTOCOL_VERSION
 |       |
 |       -- PROTOCOL_TYPE
 |
 -- MSG_PARAMS
         |
         -- OBJECT
             |
             -- (Actually contains function-specific leaf item)
        ...
</pre>

Example:

<pre>

// Function parameter success.
//
// true, if successful
// false, if failed
TSharedPtr<ISchemaItem> success_SchemaItem = CBoolSchemaItem::create(TSchemaItemParameter<bool>());

// Function parameter resultCode.
//
// See Result
TSharedPtr<ISchemaItem> resultCode_SchemaItem = TEnumSchemaItem<Result::eType>::create(resultCode_allowedEnumSubsetValues, TSchemaItemParameter<Result::eType>());

// Function parameter info.
//
// Provides additional human readable info regarding the result.
TSharedPtr<ISchemaItem> info_SchemaItem = CStringSchemaItem::create(TSchemaItemParameter<size_t>(1000), TSchemaItemParameter<std::string>());

schemaMembersMap["success"] = CObjectSchemaItem::SMember(success_SchemaItem, true);

schemaMembersMap["resultCode"] = CObjectSchemaItem::SMember(resultCode_SchemaItem, true);

schemaMembersMap["info"] = CObjectSchemaItem::SMember(info_SchemaItem, false);

std::map<std::string, CObjectSchemaItem::SMember> paramsMembersMap;

paramsMembersMap[NsSmartDeviceLink::NsJSONHandler::strings::S_FUNCTION_ID] = CObjectSchemaItem::SMember(TEnumSchemaItem<FunctionID::eType>::create(FunctionIDItems), true);

paramsMembersMap[NsSmartDeviceLink::NsJSONHandler::strings::S_MESSAGE_TYPE] = CObjectSchemaItem::SMember(TEnumSchemaItem<messageType::eType>::create(MessageTypeItems), true);

paramsMembersMap[NsSmartDeviceLink::NsJSONHandler::strings::S_CORRELATION_ID] = CObjectSchemaItem::SMember(TNumberSchemaItem<int>::create(), true);

paramsMembersMap[NsSmartDeviceLink::NsJSONHandler::strings::S_PROTOCOL_VERSION] = CObjectSchemaItem::SMember(TNumberSchemaItem<int>::create(1, 2), true);

paramsMembersMap[NsSmartDeviceLink::NsJSONHandler::strings::S_PROTOCOL_TYPE] = CObjectSchemaItem::SMember(TNumberSchemaItem<int>::create(), true);

std::map<std::string, CObjectSchemaItem::SMember> rootMembersMap;

rootMembersMap[NsSmartDeviceLink::NsJSONHandler::strings::S_MSG_PARAMS] = CObjectSchemaItem::SMember(CObjectSchemaItem::create(schemaMembersMap), true);

rootMembersMap[NsSmartDeviceLink::NsJSONHandler::strings::S_PARAMS] = CObjectSchemaItem::SMember(CObjectSchemaItem::create(paramsMembersMap), true);


CSmartSchema(CObjectSchemaItem::create(rootMembersMap));

</pre>

*/
